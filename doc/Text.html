<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<!-- steal these colour values from JavaDocs; meh -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>Text</title>
</head>


<body>

<h1>Text</h1>

<ul>
	<li><a href = "#_declarations">Declarations</a></li>
	<li><a href = "#_summary">Function Summary</a></li>
	<li><a href = "#_detail">Function Detail</a></li>
</ul>

<p>
2017 Neil Edelman, distributed under the terms of the MIT License;
see readme.txt, or <a href = "https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>.
</p>
<p>
A dynamic string, intended to be used with modified UTF-8 encoding,
<a href = "https://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8">https://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8</a>. That is, this is a
wrapper that automatically expands memory as needed around a standard C
null-terminated string in a monolithic array and is compatible with <em>ASCII</em>.
If you need to edit a potentially large string just one of <em>Text</em> will be
generally linear-time and is unsuited alone for such a purpose.
</p>
<p>
<a href = "#TextGet">TextGet</a> exposes a read-only, null-terminated <em>char *</em>. If an error
occurs, (with memory allocation, for example,) these functions shall return a
null pointer; all functions shall accept a null pointer being passed to them
and return null immediately: this means one can compose functions safely.
Reset the error with <a href = "#TextGetError">TextGetError</a>; also, <a href = "#TextIsError">TextIsError</a>.
</p>
<dl>
	<dt>minimum standard</dt>
	<dd>C89/90; part of Common</dd>
	<dt>author</dt>
	<dd>Neil</dd>
	<dt>version</dt>
	<dd>2018-01</dd>
	<dt>since</dt>
	<dd>2017-03</dd>
	<dt>fixme</dt>
	<dd>TextCharAt, TextDelete, TextInsert,
 TextSetCharAt, TextSubsequence?</dd>
</dl>


<a name = "_declarations"><!-- --></a><h2>Declarations</h2>

<div><a name = "struct Text"><!-- --></a>
<h3>struct Text</h3>
<pre><b>struct Text</b></pre>
<p>
See <a href = "#Text">Text</a>.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*TextAction)(struct Text *const)"><!-- --></a>
<h3>typedef void (*TextAction)(struct Text *const)</h3>
<pre><b>typedef void (*TextAction)(struct Text *const)</b></pre>
<p>
Action function.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef int (*TextPredicate)(const char *const string, const char *sub)"><!-- --></a>
<h3>typedef int (*TextPredicate)(const char *const string, const char *sub)</h3>
<pre><b>typedef int (*TextPredicate)(const char *const string, const char *sub)</b></pre>
<p>
Predicate function.
</p>
<dl>
	<dt>parameter: string</dt>
	<dd>The string.</dd>
	<dt>parameter: sub</dt>
	<dd>The position in the string which you must make a true/false
 decision. Necessarily, <em>sub &isin; string</em>.</dd>
</dl>
</div>

<div><a name = "struct TextPattern"><!-- --></a>
<h3>struct TextPattern</h3>
<pre><b>struct TextPattern</b> {
	const char *start, *end;
	TextAction transform;
}</pre>
<p>
Used in <a href = "#TextMatch">TextMatch</a> as an array of patterns. Recognises brackets.
</p>
<dl>
	<dt>parameter: start</dt>
	<dd>Must be at least one character.</dd>
	<dt>parameter: end</dt>
	<dd>can be null, in which case, <em>start</em> is the whole text.</dd>
	<dt>parameter: transform</dt>
	<dd>if <em>end</em>, copies a buffer (<em>start</em>, <em>end</em>) as argument;
 can be null, it will just ignore.</dd>
</dl>
</div>


<a name = "_summary"><!-- --></a><h2>Function Summary</h2>

<table>
<tr><th>Return Type</th><th>Function Name</th><th>Argument List</th></tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#Text">Text</a></td>
	<td>void</td>
</tr>
<tr>
	<td>void</td>
	<td><a href = "#Text_">Text_</a></td>
	<td>struct Text **const this_ptr</td>
</tr>
<tr>
	<td>const char *</td>
	<td><a href = "#TextGet">TextGet</a></td>
	<td>const struct Text *const this</td>
</tr>
<tr>
	<td>size_t</td>
	<td><a href = "#TextGetLength">TextGetLength</a></td>
	<td>const struct Text *const this</td>
</tr>
<tr>
	<td>size_t</td>
	<td><a href = "#TextCodePointCount">TextCodePointCount</a></td>
	<td>const struct Text *const this</td>
</tr>
<tr>
	<td>int</td>
	<td><a href = "#TextHasContent">TextHasContent</a></td>
	<td>const struct Text *const this</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextClear">TextClear</a></td>
	<td>struct Text *const this</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextTrim">TextTrim</a></td>
	<td>struct Text *const this</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextSep">TextSep</a></td>
	<td>struct Text *const this, const char *delims,
	const TextPredicate pred</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextCopy">TextCopy</a></td>
	<td>struct Text *const this, const char *const str</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextCat">TextCat</a></td>
	<td>struct Text *const this, const char *const str</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextNCat">TextNCat</a></td>
	<td>struct Text *const this, const char *const str,
	const size_t str_len</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextBetweenCat">TextBetweenCat</a></td>
	<td>struct Text *const this,
	const char *const a, const char *const b</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextFileCat">TextFileCat</a></td>
	<td>struct Text *const this, FILE *const fp</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextPrintCat">TextPrintCat</a></td>
	<td>struct Text *const this, const char *const fmt, ...</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextTransform">TextTransform</a></td>
	<td>struct Text *const this, const char *fmt</td>
</tr>
<tr>
	<td>struct Text *</td>
	<td><a href = "#TextMatch">TextMatch</a></td>
	<td>struct Text *const this,
	const struct TextPattern *const patterns, const size_t patterns_size</td>
</tr>
<tr>
	<td>int</td>
	<td><a href = "#TextGetMatchInfo">TextGetMatchInfo</a></td>
	<td>struct Text **parent_ptr,
	size_t *const start_ptr, size_t *const end_ptr</td>
</tr>
<tr>
	<td>int</td>
	<td><a href = "#TextIsError">TextIsError</a></td>
	<td>struct Text *const this</td>
</tr>
<tr>
	<td>const char *</td>
	<td><a href = "#TextGetError">TextGetError</a></td>
	<td>struct Text *const this</td>
</tr>
</table>


<a name = "_detail"><!-- --></a><h2>Function Detail</h2>

<div><a name = "Text"><!-- --></a>
<h3>Text</h3>
<pre>struct Text * <b>Text</b> (void)</pre>
<dl>
	<dt>return</dt>
	<dd>A new, blank Text, will be constructed.</dd>
	<dt>throws</dt>
	<dd>E_ERRNO</dd>
</dl>
</div>

<div><a name = "Text_"><!-- --></a>
<h3>Text_</h3>
<pre>void <b>Text_</b> (struct Text **const this_ptr)</pre>
<dl>
	<dt>parameter: this_ptr</dt>
	<dd>A pointer to Text that will be destructed.</dd>
</dl>
</div>

<div><a name = "TextGet"><!-- --></a>
<h3>TextGet</h3>
<pre>const char * <b>TextGet</b> (const struct Text *const this)</pre>
<p>
Volatile, in the sense that it exposes the buffer; specifically, not
guaranteed to last between <em>Text</em> calls to the same object. If you want a
copy, do <em>strdup(TextGet(text))</em>.
</p>
<dl>
	<dt>return</dt>
	<dd>The string associated to <em>this</em>.</dd>
</dl>
</div>

<div><a name = "TextGetLength"><!-- --></a>
<h3>TextGetLength</h3>
<pre>size_t <b>TextGetLength</b> (const struct Text *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>Gets the length in bytes, not code-points.</dd>
	<dt>order</dt>
	<dd>O(1)</dd>
</dl>
</div>

<div><a name = "TextCodePointCount"><!-- --></a>
<h3>TextCodePointCount</h3>
<pre>size_t <b>TextCodePointCount</b> (const struct Text *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>How many code-points in
 <a href = "https://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8">https://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8</a>. If it is not a
 valid string in <em>UTF-8</em>, this will return an undefined value between
 <em>[0, size]</em>.</dd>
	<dt>order</dt>
	<dd>O(<em>size</em>)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
</dl>
</div>

<div><a name = "TextHasContent"><!-- --></a>
<h3>TextHasContent</h3>
<pre>int <b>TextHasContent</b> (const struct Text *const this)</pre>
<p>
Opposite of <em>isEmpty</em>; the justification for it being this way is we want
to be say <em>TextHasContents(0) = 0</em>. Use to see if <a href = "#TextSep">TextSep</a> has any more
tokens.
</p>
<dl>
	<dt>return</dt>
	<dd>True if the buffer is not empty.</dd>
</dl>
</div>

<div><a name = "TextClear"><!-- --></a>
<h3>TextClear</h3>
<pre>struct Text * <b>TextClear</b> (struct Text *const this)</pre>
<p>
Clears the Text.
</p>
<dl>
	<dt>return</dt>
	<dd><em>this</em>.</dd>
</dl>
</div>

<div><a name = "TextTrim"><!-- --></a>
<h3>TextTrim</h3>
<pre>struct Text * <b>TextTrim</b> (struct Text *const this)</pre>
<p>
White-space trims the buffer associated with <em>this</em> using <em>isspace</em>.
</p>
<dl>
	<dt>return</dt>
	<dd><em>this</em>.</dd>
</dl>
</div>

<div><a name = "TextSep"><!-- --></a>
<h3>TextSep</h3>
<pre>struct Text * <b>TextSep</b> (struct Text *const this, const char *delims,
	const TextPredicate pred)</pre>
<p>
Separates a new token at the first <em>delims</em> that satisfy <em>pred</em>.
</p>
<dl>
	<dt>parameter: delims</dt>
	<dd>If null, uses <em>POSIX</em> white-space to separate.</dd>
	<dt>parameter: pred</dt>
	<dd>Can be null, in which case, it behaves like true.</dd>
	<dt>return</dt>
	<dd>A new <em>Text</em> or null if the tokenisation is finished or an error
 occurs. You must call <a href = "#Text_">Text_</a> on this pointer if it is not null.</dd>
	<dt>throws</dt>
	<dd>E_OVERFLOW, E_ERRNO</dd>
	<dt>fixme</dt>
	<dd>Since <em>Text</em> are necessarily non-null, this tests if it's an empty
 string; therefore, this will differ from <em>strsep</em> slightly (in a Bad way.)
 Namely, if the string ends with a token in <em>delims</em>, the last empty string
 will not be returned.</dd>
</dl>
</div>

<div><a name = "TextCopy"><!-- --></a>
<h3>TextCopy</h3>
<pre>struct Text * <b>TextCopy</b> (struct Text *const this, const char *const str)</pre>
<p>
Replaces the buffer in <em>this</em> with <em>str</em>.
</p>
<dl>
	<dt>return</dt>
	<dd><em>this</em>.</dd>
	<dt>throws</dt>
	<dd>E_PARAMETER, E_OVERFLOW, E_ERRNO</dd>
</dl>
</div>

<div><a name = "TextCat"><!-- --></a>
<h3>TextCat</h3>
<pre>struct Text * <b>TextCat</b> (struct Text *const this, const char *const str)</pre>
<p>
Concatenates <em>cat</em> onto the buffer in <em>this</em>.
</p>
<dl>
	<dt>return</dt>
	<dd><em>this</em>.</dd>
	<dt>throws</dt>
	<dd>E_PARAMETER, E_OVERFLOW, E_ERRNO</dd>
</dl>
</div>

<div><a name = "TextNCat"><!-- --></a>
<h3>TextNCat</h3>
<pre>struct Text * <b>TextNCat</b> (struct Text *const this, const char *const str,
	const size_t str_len)</pre>
<p>
Concatenates up to <em>cat_len</em> characters of <em>cat</em> onto the buffer in <em>this</em>.
</p>
<dl>
	<dt>return</dt>
	<dd><em>this</em>.</dd>
	<dt>throws</dt>
	<dd>E_PARAMETER, E_OVERFLOW, E_ERRNO</dd>
</dl>
</div>

<div><a name = "TextBetweenCat"><!-- --></a>
<h3>TextBetweenCat</h3>
<pre>struct Text * <b>TextBetweenCat</b> (struct Text *const this,
	const char *const a, const char *const b)</pre>
<p>
Concatenates <em>this</em> with <em>[a, b]</em>. If <em>a</em> &gt; <em>b</em>, then empty.
</p>
<dl>
	<dt>return</dt>
	<dd><em>this</em>.</dd>
	<dt>throws</dt>
	<dd>E_PARAMETER, E_OVERFLOW, E_ERRNO</dd>
</dl>
</div>

<div><a name = "TextFileCat"><!-- --></a>
<h3>TextFileCat</h3>
<pre>struct Text * <b>TextFileCat</b> (struct Text *const this, FILE *const fp)</pre>
<p>
Concatenates the contents of the text file, <em>fp</em>, after the read cursor, to
the buffer in <em>this</em>. On success, the read cursor will be at the end.
</p>
<dl>
	<dt>return</dt>
	<dd><em>this</em>.</dd>
	<dt>throws</dt>
	<dd>E_PARAMETER, E_OVERFLOW, E_ERRNO</dd>
</dl>
</div>

<div><a name = "TextPrintCat"><!-- --></a>
<h3>TextPrintCat</h3>
<pre>struct Text * <b>TextPrintCat</b> (struct Text *const this, const char *const fmt, ...)</pre>
<p>
Concatenates the buffer with a <em>printf</em>;
<a href = "http://pubs.opengroup.org/onlinepubs/007908799/xsh/fprintf.html">http://pubs.opengroup.org/onlinepubs/007908799/xsh/fprintf.html</a>.
</p>
<dl>
	<dt>return</dt>
	<dd><em>this</em>.</dd>
	<dt>fixme</dt>
	<dd>Have a function that allows replacing in the middle,
 TextPrintCat(this, fmt, ...) -&gt; TextPrint(this, n, fmt, ...)</dd>
</dl>
</div>

<div><a name = "TextTransform"><!-- --></a>
<h3>TextTransform</h3>
<pre>struct Text * <b>TextTransform</b> (struct Text *const this, const char *fmt)</pre>
<p>
Transforms the original text according to <em>fmt</em>.
</p>
<dl>
	<dt>parameter: fmt</dt>
	<dd>Accepts %% as '%' and %s as the original string.</dd>
	<dt>return</dt>
	<dd><em>this</em>.</dd>
	<dt>throws</dt>
	<dd>E_OVERFLOW, E_ERRNO</dd>
</dl>
</div>

<div><a name = "TextMatch"><!-- --></a>
<h3>TextMatch</h3>
<pre>struct Text * <b>TextMatch</b> (struct Text *const this,
	const struct TextPattern *const patterns, const size_t patterns_size)</pre>
<p>
Transforms {this} according to all specified {patterns} array of
{patterns_size}.
</p>
<dl>
	<dt>parameter: patterns</dt>
	<dd>An array of {TextPattern { const char *start, *end;
 TextAction transform; }; when the {begin} of a pattern encompasses another
 pattern, it should be before in the array. All patterns must have a non-empty
 string, {begin}, and {TextAction}, {transform}; {end} is optional; where
 missing, it will just call {transform} with {begin}.</dd>
	<dt>return</dt>
	<dd>{this}.</dd>
</dl>
</div>

<div><a name = "TextGetMatchInfo"><!-- --></a>
<h3>TextGetMatchInfo</h3>
<pre>int <b>TextGetMatchInfo</b> (struct Text **parent_ptr,
	size_t *const start_ptr, size_t *const end_ptr)</pre>
<p>
When <em>TextMatch</em> finds a match, it also stores a global data on where the
match occurred within the parent. This gets that information for the handler.
Concurrent uses of <a href = "#TextMatch">TextMatch</a> leave this fuction ill-defined. If any
pointers passed are null, ignores them. If one calls <a href = "#TextMatch">TextMatch</a> from
within the handler, then <em>TextGetMatchInfo</em> will not work after that point.
</p>
<dl>
	<dt>return</dt>
	<dd>Success; otherwise the values are invalid and will not be set.</dd>
</dl>
</div>

<div><a name = "TextIsError"><!-- --></a>
<h3>TextIsError</h3>
<pre>int <b>TextIsError</b> (struct Text *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>Whether an error has occurred on <em>this</em>; can be null.</dd>
</dl>
</div>

<div><a name = "TextGetError"><!-- --></a>
<h3>TextGetError</h3>
<pre>const char * <b>TextGetError</b> (struct Text *const this)</pre>
<p>
Resets the error flag.
</p>
<dl>
	<dt>return</dt>
	<dd>A lower-case string, (or in the case of a E_ERRNO, the first letter
 has an extraneous upper case on most systems,) without any punctuation, that
 explains the last error associated with <em>this</em>; can be null.</dd>
</dl>
</div>


</body>
</html>
